[{"name":"card.html","uuid":"fa246bbf-873d-474f-8bce-c307f65029fb","code":"  <div class=\"viewer\">\n    <div class=\"card\">\n      <div class=\"card-front\">\n        <div class=\"border\"></div>\n        <div class=\"card-art\">\n          {children.0.html}\n        </div>\n        <div class=\"shine\"></div>\n      </div>\n      <div class=\"card-back\">\n        <div class=\"border\"></div>\n        <div class=\"card-art\">\n          {children.1.html}\n        </div>\n        <div class=\"shine\"></div>\n      </div>\n    </div>\n  </div>"},{"name":"card-filters.html","uuid":"44021c84-6a17-4fc1-8f14-7135d19ca6db","code":"<svg class=\"svg-filters\" style=\"position:absolute;width:0;height:0;overflow:hidden;\">\n  <defs>\n      <!-- Analog noise filter -->\n      <filter id=\"turbulence-glitch\">\n        <feTurbulence type=\"fractalNoise\" baseFrequency=\"0.0001 0.0001\" numOctaves=\"1\" result=\"warp\"></feTurbulence>\n        <feDisplacementMap xChannelSelector=\"R\" yChannelSelector=\"G\" scale=\"30\" in=\"SourceGraphic\" in2=\"warp\" />\n      </filter>\n    \n      <!-- Screen lines -->\n      <filter id=\"screen-lines\" x=\"0\" y=\"0\" width=\"100vw\" height=\"100vh\">\n        <feFlood flood-color=\"#808080\" result=\"neutral-gray\" />\n        <feTurbulence in=\"neutral-gray\" type=\"fractalNoise\" baseFrequency=\"0.005 3\" numOctaves=\"5\" stitchTiles=\"stitch\" result=\"noise\" />\n        <feColorMatrix in=\"noise\" type=\"saturate\" values=\"0\" result=\"destaturatedNoise\"></feColorMatrix>\n        <feComponentTransfer in=\"desaturatedNoise\" result=\"theNoise\">\n          <feFuncA type=\"table\" tableValues=\"0 0 0.2 0\"></feFuncA>\n        </feComponentTransfer>\n        <feBlend in=\"SourceGraphic\" in2=\"theNoise\" mode=\"soft-light\" result=\"noisy-image\" />\n      </filter>\n    \n    <!-- Screen noise -->\n      <filter id=\"noise\" x=\"-50vw\" y=\"-50vh\" width=\"150vw\" height=\"150vh\">\n        <feFlood flood-color=\"#808080\" result=\"neutral-gray\" />\n        <feTurbulence in=\"neutral-gray\" type=\"fractalNoise\" baseFrequency=\"0.75\" seed=\"1\" numOctaves=\"10\" stitchTiles=\"stitch\" result=\"noise\" />\n        <feColorMatrix in=\"noise\" type=\"saturate\" values=\"0\" result=\"destaturatedNoise\"></feColorMatrix>\n        <feComponentTransfer in=\"desaturatedNoise\" result=\"theNoise\">\n          <feFuncA type=\"table\" tableValues=\"0 0 0.2 0\"></feFuncA>\n        </feComponentTransfer>\n        <feBlend in=\"SourceGraphic\" in2=\"theNoise\" mode=\"soft-light\" result=\"noisy-image\" />\n      </filter>\n    \n    <!-- Chromatic Abberation Filter -->\n      <filter \n        id=\"chromatic-aberration\" \n        filterUnits=\"userSpaceOnUse\" \n        color-interpolation-filters=\"sRGB\"\n        x=\"0\" y=\"0\" width=\"544\" height=\"720\">\n        \n        <feOffset in=\"SourceGraphic\" result=\"pre-red\" dx=\"-1\" dy=\"0\"></feOffset>\n        <feOffset in=\"SourceGraphic\" result=\"pre-green\" dx=\"1\" dy=\"0\"></feOffset>\n        <feOffset in=\"SourceGraphic\" result=\"pre-blue\" dx=\"0\" dy=\"-1\"></feOffset>\n\n        <feColorMatrix \n          in=\"pre-red\" \n          type=\"matrix\" \n          result=\"red\" \n          values=\"1 0 0 0 0\n                  0 0 0 0 0\n                  0 0 0 0 0\n                  0 0 0 1 0\"> \n        </feColorMatrix>\n        \n        <feColorMatrix \n          in=\"pre-blue\" \n          type=\"matrix\" \n          result=\"blue\" \n          values=\"0 0 0 0 0\n                  0 0 0 0 0\n                  0 0 1 0 0\n                  0 0 0 1 0\"> \n          \n        </feColorMatrix>\n\n        <feColorMatrix \n          in=\"pre-green\" \n          type=\"matrix\" \n          result=\"green\" \n          values=\"0 0 0 0 0\n                  0 1 0 0 0\n                  0 0 0 0 0\n                  0 0 0 1 0\"> \n        </feColorMatrix>\n\n        \n        <feBlend mode=\"screen\" in=\"red\" in2=\"blue\" result=\"main\"></feBlend>\n        <feBlend mode=\"screen\" in=\"main\" in2=\"green\" result=\"main1\"></feBlend>\n        <feBlend mode=\"normal\" in=\"main1\" in2=\"SourceGraphic\" result=\"main2\"></feBlend>\n        <feBlend mode=\"normal\" in=\"main2\" in2=\"SourceGraphic\" result=\"main3\"></feBlend>\n        \n        <!--feGaussianBlur in=\"main3\" stdDeviation=\"0.25\"-->\n        <!--feComposite in=\"SourceGraphic\" in2=\"main1\" operator=\"xor\" result=\"comp\"></feComposite-->\n        <feMerge>\n          <!--feMergeNode in=\"SourceGraphic\"></feMergeNode-->\n          <!--feMergeNode in=\"red\"></feMergeNode>\n          <feMergeNode in=\"green\"></feMergeNode>\n          <feMergeNode in=\"blue\"></feMergeNode--> \n          <feMergeNode in=\"main3\" />\n\n        </feMerge>\n\n      </filter>\n      <filter id=\"test\">\n  <feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"3\"/> \n  <feOffset dx=\"-4\" dy=\"0\"/>\n  <feColorMatrix values=\"0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0\"/>\n  <feMerge> \n    <feMergeNode/>\n    <feMergeNode in=\"BlurredGraphic\"/> \n  </feMerge>\n</filter>\n    \n  </defs>\n</svg>\n<script>\n  (() => {\n    let card = document.querySelector(\".card\")\n    let chromaticAbberation = document.querySelector(\"#chromatic-aberration\")\n    chromaticAbberation.setAttribute(\"width\", card.clientWidth * 2)\n    chromaticAbberation.setAttribute(\"height\", card.clientHeight * 2)\n    \n    let caOffsets = chromaticAbberation.querySelectorAll(\"feOffset\")\n    caOffsets.forEach(feOffset => {\n      feOffset.setAttribute(\"dx\", Number(feOffset.getAttribute(\"dx\")) * card.clientWidth/500)\n      feOffset.setAttribute(\"dy\", Number(feOffset.getAttribute(\"dy\")) * card.clientWidth/500)\n    })\n  })()\n</script>"},{"name":"hoverFx.script","uuid":"d9ba6928-ab3c-4b07-96d1-04cb3c57195f","code":"<script>\n  function hoverFx( object, move, leave ) {\n\n    move = move || function(){}\n    var frameId = null\n  \n    const frameListener = (e) => {\n      animationFrameID = requestAnimationFrame(frameListener)\n    }\n  \n    const mouseMove = (e) => {\n      cancelAnimationFrame(frameId)\n        frameId = requestAnimationFrame(() => {\n        var data = {\n          rect: object.getBoundingClientRect(),\n          mouseX: e.clientX,\n          mouseY: e.clientY\n        }\n        data.xPercent = Math.abs(data.rect.x - data.mouseX)/data.rect.width * 100\n        data.yPercent = Math.abs(data.rect.y - data.mouseY)/data.rect.height * 100\n        move(object,data)\n        });\n    }\n    const mouseLeave = (e) => {\n      if(typeof leave === \"function\"){\n        leave(object)\n      }\n    }\n    object.addEventListener('mousemove', mouseMove)\n    object.addEventListener('mouseleave', mouseLeave)\n  \n  }\n</script>"},{"name":"card.style","uuid":"8efd6e3a-ec2f-4d05-9391-b4c4d98107f9","code":"<style>\n  *, \n  *:before, \n  *:after{\n    box-sizing: border-box;\n  }\n  :root{\n    --card-radius: 16px;\n  }\n  html, body{\n    padding: 0;\n    margin: 0;\n    width: 100%;\n    height: 100%;\n  }\n  body{\n    background: #24292B;\n  }\n  .viewer{\n    position: fixed;\n    perspective: 1000px;\n    perspective-origin: 50% 50%;\n    left:50%;\n    top: 50%;\n    transform: translate(-50%,-50%);\n  }\n  .card{\n    transform-style: preserve-3d;\n    -webkit-transform-style: preserve-3d;\n    perspective: 1000px;\n  }\n  .card-front,\n  .card-back{\n    will-change: transform,filter, box-shadow,z-index;\n    padding: 4px;\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden;\n    position:relative;\n    border-radius: var(--card-radius);\n    overflow: hidden;\n  }\n  body:after{\n    content:'';\n    background: rgba(0,0,0,0);\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    will-change: backdrop-filter;\n    backdrop-filter: blur(0.2px);\n    -webkit-backdrop-filter: blur(0.15px);\n  }\n  .card-art {\n    border-radius: calc(var(--card-radius) * 0.75);\n    overflow: hidden;\n    position: relative;\n    z-index: 1;\n  }\n  .card-back{\n    transform: rotateY(180deg);\n    position: absolute;\n    left: 0;\n    top: 0;\n  }\n.card .holo{\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  mix-blend-mode: hue;\n  opacity: 1;\n  z-index: 1;\n  overflow: hidden;\n  transform-style: preserve-3d;\n  will-change: mix-blend-mod;\n  border-radius: var(--card-radius);\n}\n.card .holo canvas{\n  width: 100%;\n  height: 100%;\n}\n.card .shine{\n  position: absolute;\n  left:-50%;\n  top:-50%;\n  right: -50%;\n  bottom: -50%;\n  border-radius: var(--card-radius);\n  background-size: 100% 100%;\n  background-position: 50% 50%;\n  background-repeat: no-repeat;\n  z-index:3;\n  will-change: transform;\n}\n.card .shine:after{\n  content: '';\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  width: 4px;\n  height: 4px;\n  border-radius: 2px;\n  background: rgba(255,255,255,0.25);\n  box-shadow: 0 0 200px 200px rgba(255,255,255,0.15);\n  will-change: transform;\n  display: none;\n}\n\n.card .border{\n  position: absolute;\n  left:0;\n  top:0;\n  right: 0;\n  bottom: 0;  \n  background: rgba(255,255,255,0.5);\n  z-index: 0;\n}\n.card .border:after{\n  content: '';\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 0;\n  height: 0;\n  animation: borderShine 10000ms linear infinite;\n  box-shadow: 0 0 40px 40px rgba(255,255,255,1),0 0 40px 40px rgba(255,255,255,1);\n  will-change: transform;\n  transform: translateX(-50%) translateY(-50%);\n  mix-blend-mode: overlay;\n}\n\n.card--autospin{\n  animation: cardSpin 6s linear infinite;\n}\n.card--autospin .shine{\n  animation: cardShine 1.5s linear infinite;\n}\n.card--autospin .shine:after{\n  display: block;\n}\n\n@keyframes cardShine{\n  from{\n    transform: translateX(400%);\n  }\n  to{\n    transform: translateX(-400%);\n  }\n}\n\n@keyframes borderShine{\n  from{\n   transform: translateX(-50%) translateY(-50%);\n  }\n  25%{\n    transform: translateX(calc(272px - 50%)) translateY(-50%);\n  }\n  50%{\n    transform: translateX(calc(272px - 50%)) translateY(calc(360px - 50%));\n  }\n  75%{\n    transform: translateX(-50%) translateY(calc(360px - 50%));\n  }\n}\n\n  @keyframes cardSpin{\n    0%{\n      transform: rotateY(0deg);\n    }\n    100%{\n      transform: rotateY(360deg);\n    }\n  }\n\n</style>"},{"name":"card-rotate.script","uuid":"4c8de4fb-f862-478b-a511-8c4b39fa9a86","code":"<script>\n  let card = document.querySelector(\".card\")\n  let cardFront = card.querySelector(\".card-front\")\n  let cardBack = card.querySelector(\".card-back\")\n  let cardShineFront = cardFront.querySelector(\".shine\")\n  let cardShineBack = cardBack.querySelector(\".shine\")\n  let rotateY = 0\n  let rotateX = 0\n  let autoSpin = true\n  let hoverTimeoutId\n  \n  card.classList.add('card--autospin')\n  \n  let rotate = () => {\n    if(autoSpin){\n      rotateY = rotateY % 360 + 1\n      rotateX = rotateX - 1 > 0? rotateX - 1: (rotateX + 1 < 0? rotateX + 1: 0)\n    }\n    card.style.transform = `rotateY(${rotateY}deg) rotateX(${rotateX}deg)`\n    \n    cardShineFront.style.backgroundImage = `radial-gradient(circle at ${-rotateY/45 * 360 + 50}% ${rotateX/45 * 360 + 50}%, rgba(255,255,255,0.75) 0%, rgba(255,255,255,0.25) 0%, rgba(255,255,255,0) 100%)`\n    \n    cardShineBack.style.backgroundImage = `radial-gradient(circle at ${-(rotateY % 180)/45 * 360 + 50}% ${rotateX/45 * 360 + 50}%, rgba(255,255,255,0.75) 0%, rgba(255,255,255,0.25) 0%, rgba(255,255,255,0) 100%)`\n   \n    let shadowIntensity = Math.abs(1 - Math.abs(rotateY % 180)/90)\n    cardBack.style.boxShadow = cardFront.style.boxShadow = `${Math.abs(rotateY)%90/10}vw ${Math.abs(rotateX)%90/2 + 6}vw 5vw -${6 * shadowIntensity}vw rgba(0,0,0,${shadowIntensity})`\n    \n  }\n  \n  hoverFx(document.documentElement,(object,data) => {\n    let {xPercent, yPercent} = data\n    rotateY = -(xPercent - 50) * 6\n    rotateX = -(yPercent - 50) \n    autoSpin = false\n    card.classList.remove('card--autospin')\n    rotate()\n    clearTimeout(hoverTimeoutId)\n    hoverTimeoutId = setTimeout(() => {\n      //autoSpin = true\n      card.classList.add('card--autospin')\n    },1000)\n  })\n  \n  \n  </script>"},{"name":"turbulence-glitch.script","uuid":"22a92c47-b7cd-413e-bfec-8f04e48afb1b","code":"<script>\n  let turb = document.querySelector('#turbulence-glitch feTurbulence')\n\n  let turbulenceGlitch = (waves = 20) => {\n    if(waves > 0){\n      turb.setAttribute('baseFrequency',`0 ${Math.sin(performance.now())*0.05}` )\n      window.requestAnimationFrame(() => {\n        turbulenceGlitch(waves - 1)\n      })\n    } else {\n      turb.setAttribute('baseFrequency','0 0')\n    }\n  }\n</script>\n<style>\n  body{\n    filter: url(#turbulence-glitch);\n  }\n</style>"},{"name":"crt.style","uuid":"e399a5db-c6c3-4793-a750-956ee9bea7ec","code":"<style>\n  @keyframes flicker {\n  0% {\n  opacity: 0.27861;\n  }\n  5% {\n  opacity: 0.34769;\n  }\n  10% {\n  opacity: 0.23604;\n  }\n  15% {\n  opacity: 0.90626;\n  }\n  20% {\n  opacity: 0.18128;\n  }\n  25% {\n  opacity: 0.83891;\n  }\n  30% {\n  opacity: 0.65583;\n  }\n  35% {\n  opacity: 0.67807;\n  }\n  40% {\n  opacity: 0.26559;\n  }\n  45% {\n  opacity: 0.84693;\n  }\n  50% {\n  opacity: 0.96019;\n  }\n  55% {\n  opacity: 0.08594;\n  }\n  60% {\n  opacity: 0.20313;\n  }\n  65% {\n  opacity: 0.71988;\n  }\n  70% {\n  opacity: 0.53455;\n  }\n  75% {\n  opacity: 0.37288;\n  }\n  80% {\n  opacity: 0.71428;\n  }\n  85% {\n  opacity: 0.70419;\n  }\n  90% {\n  opacity: 0.7003;\n  }\n  95% {\n  opacity: 0.36108;\n  }\n  100% {\n  opacity: 0.24387;\n  }\n}\n.crt{\n  display: fixed;\n  left:0;\n  top:0;\n  bottom:0;\n  right:0;\n  width: 100%;\n  height: 100%;\n  z-index: 999;\n  pointer-events: none;\n}\n.crt::after {\n  content: \" \";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  background: rgba(18, 16, 16, 0.1);\n  opacity: 0;\n  z-index: 2;\n  pointer-events: none;\n  animation: flicker 0.15s infinite;\n  -webkit-animation: none;\n  will-change: opacity;\n}\n.crt::before {\n  content: \" \";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  background: \n    linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), \n    linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));\n  z-index: 2;\n  opacity: 0.35;\n  background-size: 100% 4px, 6px 100%;\n  pointer-events: none;\n  animation: scanlines 20s linear infinite alternate;\n  -webkit-animation: none;\n  will-change: background, background-position;\n}\n@keyframes scanlines{\n  to{\n    background-position: 0 0;\n  }\n  from{\n    background-position: 0 50%;\n  }\n}\n</style>"},{"name":"static.script","uuid":"6d73c1fe-f850-4a41-bc52-f182e8a077a4","code":"<script>\n  const static = function() {\n    var viewWidth,\n        viewHeight,\n        canvas = document.createElement(\"canvas\"),\n        ctx;\n    \n    document.documentElement.appendChild(canvas)\n\n    // change these settings\n    var patternSize = 128,\n        patternScaleX = 1,\n        patternScaleY = 1,\n        patternRefreshInterval = 10,\n        patternAlpha = 10; // int between 0 and 255,\n\n    var patternPixelDataLength = patternSize * patternSize * 4,\n        patternCanvas,\n        patternCtx,\n        patternData,\n        frame = 0;\n\n    window.onload = function() {\n        initCanvas();\n        initGrain();\n        requestAnimationFrame(loop);\n    };\n\n    // create a canvas which will render the grain\n    function initCanvas() {\n        canvas.className = \"static\"\n        canvas.style.position = \"fixed\"\n        canvas.style.left = canvas.style.top = canvas.style.right = canvas.style.bottom = \"0px\"\n        canvas.style.width = \"100vw\"\n        canvas.style.height = \"100vh\"\n        canvas.style.pointerEvents = \"none\"\n        viewWidth = canvas.width = canvas.clientWidth;\n        viewHeight = canvas.height = canvas.clientHeight;\n        ctx = canvas.getContext('2d');\n\n        ctx.scale(patternScaleX, patternScaleY);\n    }\n\n    // create a canvas which will be used as a pattern\n    function initGrain() {\n        patternCanvas = document.createElement('canvas');\n        patternCanvas.width = patternSize;\n        patternCanvas.height = patternSize;\n        patternCtx = patternCanvas.getContext('2d');\n        patternData = patternCtx.createImageData(patternSize, patternSize);\n    }\n\n    // put a random shade of gray into every pixel of the pattern\n    function update() {\n        var value;\n\n        for (var i = 0; i < patternPixelDataLength; i += 4) {\n            value = (Math.random() * 255) | 0;\n\n            patternData.data[i    ] = value;\n            patternData.data[i + 1] = value;\n            patternData.data[i + 2] = value;\n            patternData.data[i + 3] = patternAlpha;\n        }\n\n        patternCtx.putImageData(patternData, 0, 0);\n    }\n\n    // fill the canvas using the pattern\n    function draw() {\n        ctx.clearRect(0, 0, viewWidth, viewHeight);\n\n        ctx.fillStyle = ctx.createPattern(patternCanvas, 'repeat');\n        ctx.fillRect(0, 0, viewWidth, viewHeight);\n    }\n\n    function loop() {\n        if (++frame % patternRefreshInterval === 0) {\n            update();\n            draw();\n        }\n\n        requestAnimationFrame(loop);\n    }\n\n  }\n  static()\n  \n</script>"},{"name":"fx.script","uuid":"e1e88172-2ac4-4cc0-84af-f3378016e702","code":"<script>\nlet canvasFX = {\n  animatedHeightMapGradient: ({\n    canvas, \n    colors = [\n        {r:44,g:255,b:186, a: 255},\n        {r:86,g:174,b:255, a: 255},\n        {r:253,g:113,b:186, a: 255},\n        {r:255,g:241,b:170, a: 255},\n        {r:255,g:255,b:255, a: 255}\n    ],\n    shuffle = false,\n    imgSize = 256} = {} ) => {\n    \n    const c = canvas.getContext(\"2d\");\n\n    canvas.width = imgSize;\n    canvas.height = imgSize;\n\n    // init image data with black pixels\n    const image = c.createImageData(imgSize, imgSize);\n    for (let i = 0; i < image.data.length; i += 4) {\n      image.data[i] = 0; // R\n      image.data[i + 1] = 0; // G\n      image.data[i + 2] = 0; // B\n      image.data[i + 3] = 255; // A\n    }\n\n    // size of our height maps\n    const mapSize = 1024;\n\n    // returns the distance of point x,y from the origin 0,0\n    const distance = (x, y) => Math.sqrt(x * x + y * y);\n\n    // init height map 1\n    const heightMap1 = [];\n    for (let u = 0; u < mapSize; u++) {\n      for (let v = 0; v < mapSize; v++) {\n        // index of coordinate in height map array\n        const i = u * mapSize + v;\n\n        // u,v are coordinates with origin at upper left corner\n        // cx and cy are coordinates with origin at the\n        // center of the map\n        const cx = u - mapSize / 2;\n        const cy = v - mapSize / 2;\n\n        // distance from middle of map\n        const d = distance(cx, cy);\n\n        // stretching so we get the desired ripple density on our map\n        const stretch = (3 * Math.PI) / (mapSize / 2);\n\n        // wavy height value between -1 and 1\n        const ripple = Math.sin(d * stretch);\n\n        // wavy height value normalized to 0..1\n        const normalized = (ripple + 1) / 2;\n\n        // height map value 0..128, integer\n        heightMap1[i] = Math.floor(normalized * 128);\n      }\n    }\n\n    const heightMap2 = [];\n    for (let u = 0; u < mapSize; u++) {\n      for (let v = 0; v < mapSize; v++) {\n        const i = u * mapSize + v;\n        const cx = u - mapSize / 2;\n        const cy = v - mapSize / 2;\n\n        // skewed distance as input to chaos field calculation,\n        // scaled for smoothness over map distance\n        const d1 = distance(0.8 * cx, 1.3 * cy) * 0.022;\n        const d2 = distance(1.35 * cx, 0.45 * cy) * 0.022;\n\n        const s = Math.sin(d1);\n        const c = Math.cos(d2);\n        // height value between -2 and +2\n        const h = s + c;\n\n        // height value between 0..1\n        const normalized = (h + 2) / 4;\n        // height value between 0..127, integer\n        heightMap2[i] = Math.floor(normalized * 127);\n      }\n    }\n\n    // color helpers\n\n    const interpolate = (c1, c2, f) => {\n      return {\n        r: Math.floor(c1.r + (c2.r - c1.r) * f),\n        g: Math.floor(c1.g + (c2.g - c1.g) * f),\n        b: Math.floor(c1.b + (c2.b - c1.b) * f),\n        a: 255\n      }\n    }\n    \n    const shuffleArray = (array) => {\n      let copy = [...array]\n      for (let i = copy.length - 1; i > 0; i--) {\n          const j = Math.floor(Math.random() * (i + 1));\n          [copy[i], copy[j]] = [copy[j], copy[i]];\n      }\n      return copy\n    }\n\n    // returns a random color palette with 256 color entries\n    const makeRandomPalette = () => {\n      let p = shuffle? shuffleArray(colors) : colors\n      return makeFiveColorGradient(p[0],p[1],p[2],p[3],p[4])\n    }\n\n    const makeFiveColorGradient = (c1, c2, c3, c4, c5) => {\n      const g = [];\n\n      for (let i = 0; i < 64; i++) {\n        const f = i / 64;\n        g[i] = interpolate(c1, c2, f);\n      }\n\n      for (let i = 64; i < 128; i++) {\n        const f = (i - 64) / 64;\n        g[i] = interpolate(c2, c3, f);\n      }\n\n      for (let i = 128; i < 192; i++) {\n        const f = (i - 128) / 64;\n        g[i] = interpolate(c3, c4, f);\n      }\n\n      for (let i = 192; i < 256; i++) {\n        const f = (i - 192) / 64;\n        g[i] = interpolate(c4, c5, f);\n      }\n\n      return g;\n    };\n\n    // offsets for moving height maps\n    let dx1 = 0;\n    let dy1 = 0;\n\n    let dx2 = 0;\n    let dy2 = 0;\n\n    // adjust height maps offsets\n    const moveHeightMaps = t => {\n      dx1 = Math.floor(\n        (((Math.cos(t * 0.0002 + 0.4 + Math.PI) + 1) / 2) * mapSize) / 2\n      );\n      dy1 = Math.floor((((Math.cos(t * 0.0003 - 0.1) + 1) / 2) * mapSize) / 2);\n      dx2 = Math.floor((((Math.cos(t * -0.0002 + 1.2) + 1) / 2) * mapSize) / 2);\n      dy2 = Math.floor(\n        (((Math.cos(t * -0.0003 - 0.8 + Math.PI) + 1) / 2) * mapSize) / 2\n      );\n    };\n\n    // two palettes we interpolate between\n    const palettes = [makeRandomPalette(), makeRandomPalette()];\n\n    // current palette is edstablished durting animation\n    let palette = [];\n\n    // stores whether we're interpolating colors\n    // from palette 0 -> 1 (1) or 1 -> 0 (-1)\n    let prevDirection = 1;\n\n    const updatePalette = t => {\n      const timeScale = 0.0005;\n      const x = t * timeScale;\n\n      // normalized value 0..1 used to interpolate palette colors\n      const inter = (Math.cos(x) + 1) / 2;\n\n      // did we switch direction, and should ergo pick a new palette\n      // random palette to interpolate towards?\n\n      const direction = -Math.sin(x) >= 0 ? 1 : -1;\n      if (prevDirection != direction) {\n        prevDirection = direction;\n        if (direction == -1) {\n          palettes[0] = makeRandomPalette();\n        } else {\n          palettes[1] = makeRandomPalette();\n        }\n      }\n\n      // create interpolated palette for current frame\n      for (let i = 0; i < 256; i++) {\n        palette[i] = interpolate(palettes[0][i], palettes[1][i], inter);\n      }\n    };\n\n    const updateImageData = () => {\n      for (let u = 0; u < imgSize; u++) {\n        for (let v = 0; v < imgSize; v++) {\n          // indexes into height maps for pixel\n          const i = (u + dy1) * mapSize + (v + dx1);\n          const k = (u + dy2) * mapSize + (v + dx2);\n\n          // index for pixel in image data\n          // remember it's 4 bytes per pixel\n          const j = u * imgSize * 4 + v * 4;\n\n          // height value of 0..255\n          let h = heightMap1[i] + heightMap2[k];\n          // get color value from current palette\n          let c = palette[h];\n\n          // set pixel data\n          image.data[j] = c.r;\n          image.data[j + 1] = c.g;\n          image.data[j + 2] = c.b;\n          image.data[j + 3] = c.a;\n        }\n      }\n    };\n\n    // helper to create a linear gradient palette\n    const linearGradient = (c1, c2) => {\n      const g = [];\n\n      // interpolate between the colors\n      // in the gradient\n\n      for (let i = 0; i < 256; i++) {\n        const f = i / 255;\n        g[i] = interpolate(c1, c2, f);\n      }\n\n      return g;\n    };\n\n    const tick = time => {\n      moveHeightMaps(time);\n      updatePalette(time);\n      updateImageData();\n\n      c.putImageData(image, 0, 0);\n\n      requestAnimationFrame(tick);\n    };\n\n    requestAnimationFrame(tick);\n  }\n}\n\n\nlet svgFX = {\n  addFilter: (svgElement,selectors,filter) => {\n    let defs =  document.createElementNS(\"http://www.w3.org/2000/svg\",'defs')\n    svgElement.appendChild(defs)\n    defs.innerHTML = filter\n    let filterId = defs.querySelector('filter').getAttribute('id')\n    let applyToNodes = selectors? svgElement.querySelectorAll(selectors) : [svgElement]\n    \n    applyToNodes.forEach((element) => {\n      let priorFilters = element.getAttribute(\"filter\") || \"\"\n      let newFilters = `${priorFilters} url(#${filterId})`\n      element.setAttribute(\"filter\", newFilters)\n    })\n  },\n  getFilterId: (filterName) => {\n    if(!svgFX.index){\n      svgFX.index = 0\n    }\n    svgFX.index++\n    return `${filterName}_${svgFX.index}`\n  },\n  blur: (svgElement, selectors = null, stdDeviation = 0, edgeMode = \"duplicate\") => {\n    let filterId = svgFX.getFilterId(\"blur\")\n    let filter = `<filter id=\"${filterId}\">\n      <feGaussianBlur \n        in=\"SourceGraphic\" \n        edgeMode=\"${edgeMode}\"\n        stdDeviation=\"${stdDeviation}\" />\n    </filter>`\n    svgFX.addFilter(svgElement,selectors,filter)\n  },\n  chromaticAberration: (svgElement, selectors = null, offset = 1) => {\n    let filterId = svgFX.getFilterId(\"chromatic-aberration\")\n    let filter = `<filter \n        id=\"${filterId}\"\n        filterUnits=\"userSpaceOnUse\" \n        color-interpolation-filters=\"sRGB\"\n        x=\"0\" \n        y=\"0\" \n        width=\"${svgElement.clientWidth}\" \n        height=\"${svgElement.clientHeight}\">\n        <feOffset in=\"SourceGraphic\" result=\"pre-red\" dx=\"-${offset}\" dy=\"0\"></feOffset>\n        <feOffset in=\"SourceGraphic\" result=\"pre-green\" dx=\"${offset}\" dy=\"0\"></feOffset>\n        <feOffset in=\"SourceGraphic\" result=\"pre-blue\" dx=\"0\" dy=\"-${offset}\"></feOffset>\n\n        <feColorMatrix \n          in=\"pre-red\" \n          type=\"matrix\" \n          result=\"red\" \n          values=\"1 0 0 0 0\n                  0 0 0 0 0\n                  0 0 0 0 0\n                  0 0 0 1 0\"> \n        </feColorMatrix>\n        \n        <feColorMatrix \n          in=\"pre-blue\" \n          type=\"matrix\" \n          result=\"blue\" \n          values=\"0 0 0 0 0\n                  0 0 0 0 0\n                  0 0 1 0 0\n                  0 0 0 1 0\">   \n        </feColorMatrix>\n\n        <feColorMatrix \n          in=\"pre-green\" \n          type=\"matrix\" \n          result=\"green\" \n          values=\"0 0 0 0 0\n                  0 1 0 0 0\n                  0 0 0 0 0\n                  0 0 0 1 0\"> \n        </feColorMatrix>\n        \n        <feBlend mode=\"screen\" in=\"red\" in2=\"blue\" result=\"main\"></feBlend>\n        <feBlend mode=\"screen\" in=\"main\" in2=\"green\" result=\"main1\"></feBlend>\n        <feBlend mode=\"normal\" in=\"main1\" in2=\"SourceGraphic\" result=\"main2\"></feBlend>\n        <feBlend mode=\"normal\" in=\"main2\" in2=\"SourceGraphic\" result=\"main3\"></feBlend>\n      </filter>`\n      svgFX.addFilter(svgElement,selectors,filter)\n  }\n}\n\n\nfunction svgStringToCanvas(svgString) {\n  \n  let canvas = document.createElement('canvas')\n  let ctx = canvas.getContext('2d')\n  let dpr = (window.devicePixelRatio || 1) * 2\n  \n  const createSVGElement = (svg) => {\n    let div = document.createElement('div')\n    div.innerHTML = svg\n    return div.firstChild\n  }\n  let svgElement = createSVGElement(svgString)\n\n  let width = svgElement.getAttribute(\"width\")\n  let height = svgElement.getAttribute(\"height\")\n  svgElement.clientWidth = width * dpr\n  svgElement.clientHeight = height * dpr\n  \n  document.body.appendChild(svgElement)\n  \n  let img = new Image()\n  img.onload = () => {\n     canvas.width = width * dpr\n     canvas.height = height * dpr\n     canvas.style.width = `${width}px`\n     canvas.style.height = `${height}px`\n     //ctx.scale(dpr, dpr)\n     ctx.drawImage(img,0,0,canvas.width,canvas.height)\n    console.log(img.naturalWidth, img.naturalHeight)\n  }\n  img.src = `data:image/svg+xml;base64,${btoa(svgElement.outerHTML)}`\n\n  return canvas;\n}\n\n</script>"},{"name":"fx-card.script","uuid":"99385791-92b4-4530-9132-119bd1408162","code":"<script>\n\n  (() => {\n    // chromatic aberrations/blur effects\n    let cardFront = document.querySelector(\".card-front .card-art>svg\")\n    svgFX.chromaticAberration(cardFront,null,0.25)\n    svgFX.chromaticAberration(cardFront,\".label,.art,.shadow\",0.25)\n    svgFX.blur(cardFront,\".label,.art,.shadow\",0.25)\n  \n    let cardBack = document.querySelector(\".card-back .card-art>svg\")\n    svgFX.chromaticAberration(cardBack,null,0.65)\n    svgFX.blur(cardBack,null,0.25)\n  })()\n</script>"},{"name":"holo-card.script","uuid":"2dc7bf67-32aa-4b88-ab11-69381c039541","code":"<script>\n  (() => {\n    let cardFront = document.querySelector(\".card-front\")\n    let holo = document.createElement('div')\n    let c = document.createElement('canvas')\n    holo.appendChild(c)\n    holo.className = `holo` \n    cardFront.appendChild(holo)\n    canvasFX.animatedHeightMapGradient({canvas:c})\n  })()\n</script>"}]